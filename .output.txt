diff --git a/app/Services/AuthSyncService.php b/app/Services/AuthSyncService.php
index 391906e..293a92f 100644
--- a/app/Services/AuthSyncService.php
+++ b/app/Services/AuthSyncService.php
@@ -2,6 +2,9 @@

 namespace App\Services;

+use App\Models\Planet;
+use App\Models\User;
+use Illuminate\Support\Carbon;
 use Illuminate\Support\Facades\Log;

 class AuthSyncService
@@ -11,179 +14,251 @@ public function __construct(
         protected LocalStoreService $local
     ) {}

-    public function login(string $email, string $password): bool
-    {
-        try {
-            $data = $this->api->login($email, $password);
-
-            if (!isset($data['token'])) {
-                return false;
-            }
-
-            $this->local->set('auth_token', $data['token']);
+    // ----------------------------
+    // Connect / Auth token storage
+    // ----------------------------

-            // If the API doesn't return a user payload, fetch it.
-            $user = $data['user'] ?? null;
-            if (!$user) {
-                try {
-                    $user = $this->api->getUserDetails($data['token']);
-                } catch (\Throwable $e) {
-                    $user = ['email' => $email];
-                }
-            }
-
-            $this->local->set('user_data', $user);
-
-            // Cache catalog for offline
-            $this->syncPlanets(force: true);
+    public function connectRegister(User $profile, array $payload): bool
+    {
+        $result = $this->api->register($payload);

-            // Cache owned planets too (optional; safe even if empty)
-            $this->syncOwnedPlanets();
+        if (! isset($result['token'])) {
+            return false;
+        }

-            return true;
-        } catch (\Throwable $e) {
-            Log::warning('Online login failed: '.$e->getMessage());
+        $this->local->setForProfile($profile->id, 'auth_token', $result['token']);
+        $this->local->setForProfile($profile->id, 'user_data', $result['user'] ?? null);

-            // Offline auth = "do we already have a valid local session?"
-            return $this->offlineSessionLogin($email);
+        if (isset($result['user']['id'])) {
+            $profile->forceFill([
+                'tiber_user_id' => $result['user']['id'],
+                'connected_at' => now(),
+            ])->save();
         }
+
+        return true;
     }

-    public function register(array $data): bool
+    public function connectLogin(User $profile, string $email, string $password): bool
     {
-        $response = $this->api->register($data);
+        $result = $this->api->login($email, $password);

-        if (!isset($response['token'])) {
+        if (! isset($result['token'])) {
             return false;
         }

-        $this->local->set('auth_token', $response['token']);
+        $this->local->setForProfile($profile->id, 'auth_token', $result['token']);
+        $this->local->setForProfile($profile->id, 'user_data', $result['user'] ?? null);

-        $user = $response['user'] ?? null;
-        if (!$user) {
-            try {
-                $user = $this->api->getUserDetails($response['token']);
-            } catch (\Throwable $e) {
-                $user = ['email' => $data['email'] ?? null];
-            }
+        if (isset($result['user']['id'])) {
+            $profile->forceFill([
+                'tiber_user_id' => $result['user']['id'],
+                'connected_at' => now(),
+            ])->save();
         }

-        $this->local->set('user_data', $user);
+        return true;
+    }

-        $this->syncPlanets(force: true);
-        $this->syncOwnedPlanets();
+    public function tokenFor(User $profile): ?string
+    {
+        $this->local->migrateLegacyAuthToProfile($profile->id);

-        return true;
+        return $this->local->getForProfile($profile->id, 'auth_token');
     }

-    /**
-     * Offline mode should NOT be a second password system.
-     * If the user previously authenticated and we still have token + user_data,
-     * let them in (offline browsing / local play).
-     */
-    protected function offlineSessionLogin(string $email): bool
+    public function userDataFor(User $profile): mixed
     {
-        $token = $this->local->get('auth_token');
-        $userData = $this->local->get('user_data');
+        $this->local->migrateLegacyAuthToProfile($profile->id);

-        if (!$token || !$userData) {
-            return false;
-        }
+        return $this->local->getForProfile($profile->id, 'user_data');
+    }

-        return ($userData['email'] ?? null) === $email;
+    public function disconnect(User $profile): void
+    {
+        $this->local->disconnectProfile($profile->id);
+
+        $profile->forceFill([
+            'tiber_user_id' => null,
+            'connected_at' => null,
+        ])->save();
     }

+    // ----------------------------
+    // Catalog planets (offline-first)
+    // ----------------------------
+
     /**
-     * Back-compat: syncPlanets() now means "sync catalog planets"
+     * Fetch public catalog planets and upsert into local SQLite planets table.
      */
     public function syncPlanets(bool $force = false): bool
     {
-        return $this->syncCatalogPlanets($force);
-    }
+        try {
+            // If we already have local planets and not forcing, we can skip a fetch
+            // unless you want to compare meta.last_updated_at later.
+            if (! $force && Planet::query()->exists()) {
+                return false;
+            }

-    public function syncCatalogPlanets(bool $force = false): bool
-    {
-        $existing = $this->local->get('catalog_planets', null);
+            $payload = $this->api->getCatalogPlanets();
+            $rows = $payload['data'] ?? [];

-        if (!$force && is_array($existing) && count($existing) > 0) {
-            return true;
-        }
+            if (! is_array($rows) || $rows === []) {
+                return false;
+            }

-        $token = $this->local->get('auth_token');
-        if (!$token) {
-            return false;
-        }
+            $now = now();
+            $upserts = [];

-        try {
-            $planets = $this->api->getCatalogPlanets($token);
+            foreach ($rows as $p) {
+                if (! is_array($p) || empty($p['id'])) {
+                    continue;
+                }

-            // Store under the new key…
-            $this->local->set('catalog_planets', $planets);
+                $upserts[] = [
+                    'id' => (string) $p['id'],
+                    'name' => (string) ($p['name'] ?? 'Unknown'),
+                    'flavor' => (string) ($p['flavor'] ?? ''),
+                    'type' => $p['type'] ?? null,
+                    'class' => (string) ($p['class'] ?? 'standard'),
+                    'victory_point_value' => (int) ($p['victory_point_value'] ?? 0),
+                    'filename' => (string) ($p['filename'] ?? $p['id']),
+                    'is_standard' => (bool) ($p['is_standard'] ?? false),
+                    'is_purchasable' => (bool) ($p['is_purchasable'] ?? false),
+                    'is_custom' => (bool) ($p['is_custom'] ?? false),
+                    'is_promotional' => (bool) ($p['is_promotional'] ?? false),
+                    'created_at' => isset($p['created_at']) ? Carbon::parse($p['created_at']) : $now,
+                    'updated_at' => isset($p['updated_at']) ? Carbon::parse($p['updated_at']) : $now,
+                ];
+            }
+
+            if ($upserts === []) {
+                return false;
+            }
+
+            Planet::upsert(
+                $upserts,
+                ['id'],
+                [
+                    'name',
+                    'flavor',
+                    'type',
+                    'class',
+                    'victory_point_value',
+                    'filename',
+                    'is_standard',
+                    'is_purchasable',
+                    'is_custom',
+                    'is_promotional',
+                    'updated_at',
+                ]
+            );
+
+            if (! empty($payload['meta']['last_updated_at'])) {
+                $this->local->set('planets_last_updated_at', $payload['meta']['last_updated_at']);
+            }

-            // …and also under the old key so nothing else breaks today.
-            $this->local->set('planets', $planets);
+            $this->local->set('planets_last_synced_at', now()->toISOString());

             return true;
         } catch (\Throwable $e) {
-            Log::warning('Catalog planet sync failed: '.$e->getMessage());
+            Log::warning('Catalog planet sync failed: ' . $e->getMessage(), ['exception' => $e]);
             return false;
         }
     }

-    public function syncOwnedPlanets(): bool
+    /**
+     * Offline-first: returns catalog planets from local DB.
+     */
+    public function getPlanets(): array
     {
-        $token = $this->local->get('auth_token');
-        if (!$token) {
+        return Planet::query()
+            ->orderBy('name')
+            ->get()
+            ->map(fn (Planet $p) => [
+                'id' => (string) $p->id,
+                'name' => (string) $p->name,
+                'flavor' => (string) $p->flavor,
+                'type' => $p->type ? (string) $p->type : null,
+                'class' => $p->class ? (string) $p->class : null,
+                'victory_point_value' => (int) $p->victory_point_value,
+                'filename' => (string) $p->filename,
+                'is_standard' => (bool) $p->is_standard,
+                'is_purchasable' => (bool) $p->is_purchasable,
+                'is_custom' => (bool) $p->is_custom,
+                'is_promotional' => (bool) $p->is_promotional,
+            ])
+            ->all();
+    }
+
+    // ----------------------------
+    // Owned planets (per profile)
+    // ----------------------------
+
+    /**
+     * Sync the connected user's owned planets from Tiber into local pivot.
+     * Also stores owned IDs in profile secure storage as a fallback.
+     */
+    public function syncOwnedPlanets(User $profile): bool
+    {
+        $token = $this->tokenFor($profile);
+
+        if (! $token) {
             return false;
         }

         try {
-            $owned = $this->api->getPlanets($token);
-            $this->local->set('owned_planets', $owned);
+            $payload = $this->api->getPlanets($token);

-            return true;
-        } catch (\Throwable $e) {
-            Log::warning('Owned planet sync failed: '.$e->getMessage());
-            return false;
-        }
-    }
+            // Accept either {data:[...]} or [...]
+            $rows = $payload['data'] ?? $payload;

-    public function isAuthenticated(): bool
-    {
-        // Don’t treat user_data alone as auth
-        return $this->local->get('auth_token') !== null;
-    }
+            if (! is_array($rows)) {
+                return false;
+            }

-    public function getUser(): ?array
-    {
-        return $this->local->get('user_data');
-    }
+            $ids = collect($rows)
+                ->filter(fn ($p) => is_array($p) && ! empty($p['id']))
+                ->map(fn ($p) => (string) $p['id'])
+                ->values()
+                ->all();

-    /** Catalog planets */
-    public function getPlanets(): array
-    {
-        // Prefer new key; fallback to old key
-        return $this->local->get('catalog_planets', $this->local->get('planets', []));
-    }
+            // Ensure local catalog exists for these IDs (in case syncPlanets hasn't run yet)
+            if (! Planet::query()->exists()) {
+                $this->syncPlanets(force: true);
+            }

-    /** Owned planets */
-    public function getOwnedPlanets(): array
-    {
-        return $this->local->get('owned_planets', []);
-    }
+            // Pivot sync (planet_user)
+            $profile->planets()->sync($ids);

-    public function logout(): void
-    {
-        $token = $this->local->get('auth_token');
+            // Store as a quick offline fallback / debug source
+            $this->local->setForProfile($profile->id, 'owned_planet_ids', $ids);
+            $this->local->setForProfile($profile->id, 'owned_planets_last_synced_at', now()->toISOString());

-        if ($token) {
-            try {
-                $this->api->logout($token);
-            } catch (\Throwable $e) {
-                // ignore (offline / server down)
-            }
+            return true;
+        } catch (\Throwable $e) {
+            Log::warning('Owned planet sync failed: ' . $e->getMessage(), ['exception' => $e]);
+            return false;
         }
+    }

-        $this->local->clear();
+    /**
+     * Offline-first: read owned planets from local pivot.
+     */
+    public function getOwnedPlanets(User $profile): array
+    {
+        return $profile->planets()
+            ->orderBy('name')
+            ->get()
+            ->map(fn (Planet $p) => [
+                'id' => (string) $p->id,
+                'name' => (string) $p->name,
+                'flavor' => (string) $p->flavor,
+                'type' => $p->type ? (string) $p->type : null,
+                'class' => $p->class ? (string) $p->class : null,
+                'victory_point_value' => (int) $p->victory_point_value,
+                'filename' => (string) $p->filename,
+            ])
+            ->all();
     }
 }
